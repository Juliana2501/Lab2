#### Отчет по лабораторной работе № 2

#### № группы: ПМ-2501

#### Выполнила: Бизина Юлиана Кирилловна

#### Вариант: 2

### Cодержание:

Задание 1
- Постановка задачи
- Входные и выходные данные
- Выбор структуры данных
- Алгоритм
- Программа
- Анализ правильности решения
  
Задание 2
- Постановка задачи
- Входные и выходные данные
- Выбор структуры данных
- Алгоритм
- Программа
- Анализ правильности решения
  
-Задание 3
- Постановка задачи
- Входные и выходные данные
- Выбор структуры данных
- Алгоритм
- Программа
- Анализ правильности решения

Задание 4
- Постановка задачи
- Входные и выходные данные
- Выбор структуры данных
- Алгоритм
- Программа
- Анализ правильности решения

### Задание 1

### 1. Постановка задачи
>Необходимо было проанализировать последовательность, генерируемую по определенному правилу, выявить закономерность генераций данной последовательности при вводе конкретных чисел и запрограммировать ее. Последовательность строится по формуле, где каждый следующий элемент зависит от предыдущего.

### 2. Входные и выходные данные

#### Данные на вход

На вход программа должна получать 2 числа: a0 - нулевой член последовательности, по условию - целое число, и n - количество членов последовательности после нулевого элемента, по условию - натуральное число.

|             | Тип                |
|-------------|--------------------|
| a0          | Целое число        |
| n           | Целое число        |

#### Данные на выход

Программа должна вывести последовательность из n чисел.

|    Результат         | Тип             |
|----------------------|-----------------|
| Последовательность   | Массив          |

### 3. Выбор структуры данных
В задаче не дано условие множества значений целых чисел, поэтому выберем тип данных `int`, как оптимальный для данной программы, ведь int вмещает в себя числа от - 2³¹ до 2³¹, что вполне достаточно для данной программы, в отличие от `byte` или `short` со слишком небольшими диапазонами значений, а тип данных `long` занимает больше памяти и используется с большими значениями, что не является обязательным условием для нашей задачи. Программа получает 2 целых числа, поэтому для их хранения можно выделить 2 переменных (`a0` и `n`) типа `int`. 

|             | Название переменной | Тип (в Java) |   Диапазон    |
|-------------|---------------------|--------------|---------------|
| A           | a                   |   int        | -2³¹ до 2³¹-1 |
| N           | n                   |   int        | -2³¹ до 2³¹-1 |

Для вывода результата необязательно его хранить в отдельной переменной для массива, достаточно с каждой итерацией цикла for выводить получившееся число.

### 4. Алгоритм

#### Алгоритм выполнения программы:

Выявленная закономерность:
Перед началом работы с программой необходимо было выявить закономерность в последовательности. После анализа примеров понятно, что последовательность генерируется по формуле:
a{n+1} = (2 × a{n}) mod 20

1. Ввод данных:  
   Программа считывает два целых числа, обозначенные как a0 и n.

2. Инициализация переменной:
   Вводится переменная current, которой изначально присваивается значение a0. Переменная типа `long`, чтобы в случае умножения большого числа на 2 не выйти за предел диапазона типа `int`.

3. Генерация последовательности и вывод:
   Для каждого i от 0 до n-1 вычисляется и выводится на экран current = (current * 2) % 20

#### Блок-схема

```mermaid
graph TD
    A([Начало]) --> B[/Ввод: a₀, n/]
    B --> C[Инициализация current = a₀]
    C --> D{i < n?}
    D -- Да --> E[current = 2 * current % 20]
    E --> F[/Вывод current/]
    F --> G[Увеличить i на 1]
    G --> D
    D -- Нет --> H[/Вывод current/]
    H --> Z([Конец])

```

### 5. Программа

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Введите нулевой член последовательности: ");
        int a0 = scanner.nextInt();
        System.out.print("Введите длину последовательности: ");
        int n = scanner.nextInt();
        int current = a0;
        for (int i = 0; i < n; i++) {
            current = (int)((long)current * 2 % 20);
            System.out.print(current);
            if (i < n - 1) {
                System.out.print(", ");
            }
        }
    }
}

```
### 6. Анализ правильности решения

Программа работает корректно на тестовых примерах с учетом ограничений.

1.
    - **Input**:
        
        12 4
        
    - **Output**:
        
        4, 8, 16, 12

    - **Ожидаемый результат: 4, 8, 16, 12**

2.
    - **Input**:
        
        10 3
        
    - **Output**:
        
        0, 0, 0

    - **Ожидаемый результат: 0, 0, 0**

2.
    - **Input**:
        
        3 5
        
    - **Output**:
        
        6, 12, 4, 8, 16

    - **Ожидаемый результат: 6, 12, 4, 8, 16**
  
### Задание 2

### 1. Постановка задачи
>Необходимо найти в массиве позицию, на которой максимальный элемент встречается k-ый раз. Если максимальный элемент встречается меньше k раз, вывести "NO".

### 2. Входные и выходные данные

#### Данные на вход

На вход программа получает число n - размер массива, число k - порядковый номер вхождения максимума, и n целых чисел - элементы массива, n и k - целые числа, arr[i] - n целых чисел.

|             | Тип                |
|-------------|--------------------|
| n           | Целое число        |
| k           | Целое число        |
| arr[i]      | Целое число        |

#### Данные на выход

Программа должна вывести позицию k-го вхождения максимума или "NO".

|    Результат       |        Тип          |
|--------------------|---------------------|
| Позиция или "NO"   | Целое число/строка  |

### 3. Выбор структуры данных
В задаче не дано условие множества значений целых чисел, поэтому выберем тип данных int, как оптимальный для данной программы, ведь int вмещает в себя числа от -2³¹ до 2³¹-1, что вполне достаточно для данной программы, в отличие от byte или short со слишком небольшими диапазонами значений, а тип данных long занимает больше памяти и используется с большими значениями, что не является обязательным условием для нашей задачи. Программа получает n+1 целых чисел (n и n элементов массива), поэтому для их хранения можно выделить переменные типа int.

|             | Название переменной | Тип (в Java) |   Диапазон    |
|-------------|---------------------|--------------|---------------|
| N           | n                   |   int        | -2³¹ до 2³¹-1 |
| K           | k                   |   int        | -2³¹ до 2³¹-1 |
| ARR         | arr                 |   int        | -2³¹ до 2³¹-1 |
| MAX         | max                 |   int        | -2³¹ до 2³¹-1 |
| CNT         | cnt                 |   int        | -2³¹ до 2³¹-1 |
| RES         | res                 |   int        | -2³¹ до 2³¹-1 |

### 4. Алгоритм

#### Алгоритм выполнения программы:

1. Ввод данных:  
   Читаем n и k. Читаем n чисел в массив arr.
   
2. Поиск максимума:
   Проходим по массиву и находим максимальный элемент

3. Поиск k-го вхождения:
   Проходим по массиву второй раз. Для каждого элемента равного максимуму увеличиваем счетчик. Когда счетчик достигает k, сохраняем позицию

4. Вывод результата:
   Если нашли k-ое вхождение - выводим позицию. Иначе - выводим "NO"
   
#### Блок-схема

```mermaid
graph TD
    A([Начало]) --> B[/Ввод: n, k/]
    B --> C[Создать массив arr размером n]
    C --> D[/Заполнить массив arr/]
    D --> E[Найти max в массиве]
    E --> F[count = 0, result = -1]
    F --> G[i = 0]
    G --> H{i < n?}
    H -- Да --> I{arr[i] == max?}
    I -- Да --> J[count++]
    J --> K{count == k?}
    K -- Да --> L[result = i + 1]
    L --> M[i++]
    K -- Нет --> M
    I -- Нет --> M
    M --> G
    H -- Нет --> N{result >= 0?}
    N -- Да --> O[/Вывод result/]
    N -- Нет --> P[/Вывод NO/]
    O --> Z([Конец])
    P --> Z

```

### 5. Программа

```java
import java.util.Scanner;
public class Main2 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        int[] arr = new int[n];
        int max = -1000000000;
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        int cnt = 0;
        int res = -1;
        for (int i = 0; i < n; i++) {
            if (arr[i] == max) {
                cnt++;
                if (cnt == k) {
                    res = (int) (i + 1);
                }
            }
        }
        if (res >= 0) {
            System.out.println(res);
        } else {
            System.out.println("NO");
        }
    }
}

```
### 6. Анализ правильности решения

Программа работает корректно на тестовых примерах с учетом ограничений.

1.
    - **Input**:
        
        12 4
        
    - **Output**:
        
        4, 8, 16, 12

    - **Ожидаемый результат: 4, 8, 16, 12**

2.
    - **Input**:
        
        10 3
        
    - **Output**:
        
        0, 0, 0

    - **Ожидаемый результат: 0, 0, 0**

2.
    - **Input**:
        
        3 5
        
    - **Output**:
        
        6, 12, 4, 8, 16

    - **Ожидаемый результат: 6, 12, 4, 8, 16**

